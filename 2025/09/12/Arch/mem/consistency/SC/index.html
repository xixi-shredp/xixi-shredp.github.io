<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Sequential Consistency (SC) | xixi's blog</title><meta name="author" content="xixi"><meta name="copyright" content="xixi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Sequential Consistency (SC) 内存模型简介">
<meta property="og:type" content="article">
<meta property="og:title" content="Sequential Consistency (SC)">
<meta property="og:url" content="https://xixi-shredp.github.io/2025/09/12/Arch/mem/consistency/SC/index.html">
<meta property="og:site_name" content="xixi&#39;s blog">
<meta property="og:description" content="Sequential Consistency (SC) 内存模型简介">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xixi-shredp.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-09-12T09:43:39.000Z">
<meta property="article:modified_time" content="2026-02-08T15:32:07.574Z">
<meta property="article:author" content="xixi">
<meta property="article:tag" content="CPU, Computer Architechture, OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xixi-shredp.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Sequential Consistency (SC)",
  "url": "https://xixi-shredp.github.io/2025/09/12/Arch/mem/consistency/SC/",
  "image": "https://xixi-shredp.github.io/img/avatar.jpg",
  "datePublished": "2025-09-12T09:43:39.000Z",
  "dateModified": "2026-02-08T15:32:07.574Z",
  "author": [
    {
      "@type": "Person",
      "name": "xixi",
      "url": "https://xixi-shredp.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="https://xixi-shredp.github.io/2025/09/12/Arch/mem/consistency/SC/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Sequential Consistency (SC)',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/default_top.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">29</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.svg" alt="Logo"><span class="site-name">xixi's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Sequential Consistency (SC)</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Sequential Consistency (SC)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-09-12T09:43:39.000Z" title="Created 2025-09-12 17:43:39">2025-09-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-08T15:32:07.574Z" title="Updated 2026-02-08 23:32:07">2026-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/">Arch</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/mem/">mem</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/mem/consistency/">consistency</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h2 id="第一次提出的定义"><a href="#第一次提出的定义" class="headerlink" title="第一次提出的定义"></a>第一次提出的定义</h2><blockquote>
<p>L. Lamport. How to make a multiprocessor computer that correctly executes multiprocess programs. IEEE Transactions on Computers, C-28(9):690–91, September 1979. DOI: 10.1109&#x2F;tc.1979.1675439. 22, 35</p>
</blockquote>
<p>单处理器 sequential: 执行的结果与按照程序指定的顺序执行的结果相同</p>
<p>多处理器 sequentially consistent:<br>任何执行的结果都相当于以某种顺序依次执行所有处理器（核心）的操作，并且每个单独的处理器（核心）的操作按照其程序指定的顺序出现在该序列中 </p>
<p>memory order: 程序指定的所有操作的顺序</p>
<p>SC 模型严格遵守 memory order</p>
<h2 id="以公理的形式定义"><a href="#以公理的形式定义" class="headerlink" title="以公理的形式定义"></a>以公理的形式定义</h2><blockquote>
<p>D. L. Weaver and T. Germond, Eds. SPARC Architecture Manual (Version 9). PTR Prentice Hall, 1994. 23</p>
</blockquote>
<p>符号表:  </p>
<table>
<thead>
<tr>
<th>L(a) &#x2F; S(a)</th>
<th>对地址 a 的 Load&#x2F;Store</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;p</td>
<td>Program Order: 每个核顺序执行所有访存操作的 total order</td>
</tr>
<tr>
<td>&lt;m</td>
<td>Global Order: 所有核的访存操作的 total order</td>
</tr>
</tbody></table>
<p>SC execution 的要求:  </p>
<ol>
<li>所有核将自己的 load&#x2F;store 插入 global order &lt;m 的时候需满足各自的 program order &lt;p (不论访存地址是否相同)<ul>
<li>if L(a) &lt;p L(b) &#x3D;&gt; L(a) &lt;m L(b)</li>
<li>if L(a) &lt;p S(b) &#x3D;&gt; L(a) &lt;m S(b)</li>
<li>if S(a) &lt;p S(b) &#x3D;&gt; S(a) &lt;m S(b)</li>
<li>if S(a) &lt;p L(b) &#x3D;&gt; S(a) &lt;m L(b)</li>
</ul>
</li>
<li>每次 load 拿到的值是 global order 中该 load 之前的最后一次 store 的值<ul>
<li>Value of L(a) &#x3D; Value of $MAX_{&lt;m} {S(a) | S(a) &lt;m L(a)}$, $MAX_{&lt;m}$ 表示 &lt;m 中最近的操作</li>
</ul>
</li>
</ol>
<p>SC ordering rules (X 表示强制定序):  </p>
<table>
	<tr align="center">
	    <td colspan="5">Operation 2</td>
	</tr>
	<tr>
	    <td rowspan="4">Operation 1</td>
	    <td></td>
	    <td>Load</td>
	    <td>Store</td>
	    <td>RMW</td>
	</tr>
	<tr>
	    <td>Load</td>
	    <td>X</td>
	    <td>X</td>
	    <td>X</td>
	</tr>
	<tr>
	    <td>Store</td>
	    <td>X</td>
	    <td>X</td>
	    <td>X</td>
	</tr>
	<tr>
	    <td>RMW</td>
	    <td>X</td>
	    <td>X</td>
	    <td>X</td>
	</tr>
</table>

<blockquote>
<p>第一个证明每个核向其 cache(支持 cache coherence) 发出的访存请求满足 program order 时满足 SC 模型:<br>A. Meixner and D. J. Sorin. Dynamic verification of memory consistency in cachecoherent multithreaded computer architectures. In Proc. of the International Conference on Dependable Systems and Networks, pp. 73–82, June 2006. DOI: 10.1109&#x2F;dsn.2006.29. 35_</p>
</blockquote>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="Naive-Implementations"><a href="#Naive-Implementations" class="headerlink" title="Naive Implementations"></a>Naive Implementations</h2><ol>
<li>The Multitasking Uniprocessor: 在单个顺序核上执行所有线程<ul>
<li>要求上下文切换前访存操作必须全部完成。</li>
</ul>
</li>
<li>The Switch: 多个核将访存操作提交给一个 switch 选择执行<ul>
<li>每个核提交的访存操作需满足自己的 program order</li>
<li>switch 选择核来执行实际的访存，需要满足 global order</li>
<li>switch 选择的策略不能饿死某个核的 ready 请求以保证公平</li>
</ul>
</li>
</ol>
<p>The Switch:<br><img src="/images/Arch/mem/consistency/SC/the_switch.svg" alt="The Switch"></p>
<ul>
<li>满足 SC 模型</li>
<li>缺点: 顺序瓶颈问题: 不具备可扩展性（核数增多时性能瓶颈）</li>
</ul>
<h2 id="支持-Cache-Coherence-的基础实现"><a href="#支持-Cache-Coherence-的基础实现" class="headerlink" title="支持 Cache Coherence 的基础实现"></a>支持 Cache Coherence 的基础实现</h2><p><img src="/images/Arch/mem/consistency/SC/basic_sc_imple.svg" alt="支持 Cache Coherence 的基础实现"></p>
<ul>
<li>L1Cache 中的 block 需要支持 modified(M) 和 shared(S) 两个状态<ol>
<li>modified 状态表示一个核可以对其进行读写</li>
<li>shared 状态表示一个或多个核对其只可读</li>
</ol>
</li>
</ul>
<p>通过基本的 cache coherence 保证了 SWMR 的不变性以实现 SC</p>
<ol>
<li>对于地址不冲突的访存请求可以并发执行，提高可扩展性</li>
<li>将 core 的实现与 coherence 的实现解耦</li>
</ol>
<h2 id="支持-Cache-Coherence-的优化实现"><a href="#支持-Cache-Coherence-的优化实现" class="headerlink" title="支持 Cache Coherence 的优化实现"></a>支持 Cache Coherence 的优化实现</h2><p>与其他 CPU 特性结合使用以提高性能</p>
<h3 id="Non-Binding-Prefetching"><a href="#Non-Binding-Prefetching" class="headerlink" title="Non-Binding Prefetching"></a>Non-Binding Prefetching</h3><p>在 cache-coherenct memory system 中对 block 的预取会改变 block 的 coherence 状态，而对于 memory consistency model 而言预取相当于 nop ，因为对 coherence 状态的获取时间不会影响每个 core 本身的 program order</p>
<h3 id="Speculative-Cores"><a href="#Speculative-Cores" class="headerlink" title="Speculative Cores"></a>Speculative Cores</h3><p>分支指令之后的 load&#x2F;store 在遇到分支预测失败时会被冲刷出流水线。</p>
<ul>
<li>对于被冲刷的 load 而言，如果访存请求已经发出，其效果相当于预取，不会影响 SC</li>
<li>对于被冲刷的 store 而言，相当于发出 getM 的 coherence 状态请求，实际的 store 并未发生(store 只有在达到 ROB 的顶端确认可以执行时才会执行)</li>
</ul>
<h3 id="Dynamically-Scheduled-Cores"><a href="#Dynamically-Scheduled-Cores" class="headerlink" title="Dynamically Scheduled Cores"></a>Dynamically Scheduled Cores</h3><p>乱序执行&#x2F;动态调度可能会对不相关的 load 指令重排序(其他核不可见)，会违反 SC 规定的 program order</p>
<ol>
<li>对于 SC 的预测执行，需要验证乱序核的预测执行是否正确（和其他核的请求不冲突）: L1 -&gt; L2 (预测执行先执行 L2)</li>
<li>乱序核预测执行完 L2 ，在 commit L2 之前检查 cache 中 evict 的 block 以及向 cache 发出的 coherence 请求等是否和 L2 请求的 block 一致<ul>
<li>如果此时有 GetM 的请求或者 block 一致，说明其他核会试图写入该 block, 乱序核需要使预测执行失效</li>
</ul>
</li>
<li>在预测执行的 L2 指令 commit 时再次发出 load 请求<ul>
<li>如果两次 load 的值相同，说明预测执行正确，否则说明有其他核在该 load 执行和 commit 之间发出了冲突的写请求，此时乱序核需要清除预测执行</li>
<li>对于支持值预测的处理器而言，不能比较两次 load 的结果 (ABA problem)</li>
</ul>
</li>
</ol>
<blockquote>
<p>K. Gharachorloo, A. Gupta, and J. Hennessy. Two techniques to enhance the performance of memory consistency models. In Proc. of the International Conference on Parallel Processing, vol. I, pp. 355–64, August 1991. 30_</p>
</blockquote>
<h3 id="Multithreading"><a href="#Multithreading" class="headerlink" title="Multithreading"></a>Multithreading</h3><p>一个核内的多个线程共享 L1 cache ：粗粒度多线程、细粒度多线程、同时多线程</p>
<p>需要确保线程 T1 不能读到同一核内另一个线程 T2 此时正在写入的值（该写入此时对其他线程还不可见）</p>
<h3 id="Post-retirement-speculation"><a href="#Post-retirement-speculation" class="headerlink" title="Post-retirement speculation"></a>Post-retirement speculation</h3><p>单核乱序核中的 write buffer 将所有的 store 加入以隐藏 store miss latency, 同时 load 指令通过访问 write buffer 检查相关性</p>
<p>多核中 store miss latency 会更长，为提高性能, 可以预测性地使 store miss 之前的 load&#x2F;store 指令退役，同时维护这些预测性退役的指令的状态</p>
<blockquote>
<p><strong>细粒度</strong>：  </p>
<ol>
<li>C. Guiady, B. Falsafi, and T. Vijaykumar. Is SC C ILP D RC? In Proc. of the 26th Annual International Symposium on Computer Architecture, pp. 162–71, May 1999. DOI: 10.1109&#x2F;isca.1999.765948. 32</li>
<li>P. Ranganathan, V. S. Pai, and S. V. Adve. Using speculative retirement and larger instruction windows to narrow the performance gap between memory consistency models. In Proc. of the 9th ACM Symposium on Parallel Algorithms and Architectures, pp. 199–210, June 1997. DOI: 10.1145&#x2F;258492.258512. 32</li>
</ol>
<p><strong>粗粒度</strong>：  </p>
<ol>
<li>C. Blundell, M. M. K. Martin, and T. F. Wenisch. InvisiFence: Performance-transparent memory ordering in conventional multiprocessors. In Proc. of the 36th Annual International Symposium on Computer Architecture, June 2009. DOI: 10.1145&#x2F;1555754.1555785. 32</li>
<li>L. Ceze, J. Tuck, P. Montesinos, and J. Torrellas. BulkSC: Bulk enforcement of sequential consistency. In Proc. of the 34th Annual International Symposium on Computer Architecture, June 2007. DOI: 10.1145&#x2F;1250662.1250697. 32</li>
<li>L. Hammond et al. Transactional memory coherence and consistency. In Proc. of the 31st Annual International Symposium on Computer Architecture, June 2004. DOI: 10.1109&#x2F;isca.2004.1310767. 32</li>
<li>T. F. Wenisch, A. Ailamaki, A. Moshovos, and B. Falsafi. Mechanisms for store-wait-free multiprocessors. In Proc. of the 34th Annual International Symposium on Computer Architecture, June 2007. DOI: 10.1145&#x2F;1250662.1250696. 32</li>
</ol>
</blockquote>
<h3 id="Non-speculative-reordering"><a href="#Non-speculative-reordering" class="headerlink" title="Non-speculative reordering"></a>Non-speculative reordering</h3><p>采用非预测执行的方式乱序执行访存指令以满足 SC ，同时这种重排序不能被其他核看到</p>
<p>coherence delaying:<br>当一个更年轻的访存指令要退役时如果旧的访存指令还未退役，年轻访存指令的 coherence 请求会延时直到旧访存指令退役。可能会导致死锁，需要检测规避</p>
<p>predecessor serialization:<br>旧的访存操作需要确保新的访存操作在其之后完成是安全的</p>
<ol>
<li>Conflict Ordering: 允许 load&#x2F;store 在 store miss 之后退役，要求<ul>
<li>未完成的 store 是顺序的</li>
<li>新的访存操作和该 store miss 不冲突</li>
</ul>
</li>
<li>Gope and Lipasti 对于顺序处理器的定制方法: load&#x2F;store 可以顺序地从目录中取出互斥锁，乱序地退役</li>
<li>借助于编译器或者 MMU 的帮助使得访存操作被安全地重排序<ul>
<li>thread-private 和 read-only 变量可以被安全重排序</li>
</ul>
</li>
</ol>
<blockquote>
<ol>
<li>Conflict Ordering:<br>C. Lin, V. Nagarajan, R. Gupta, and B. Rajaram. Efficient sequential consistency via conflict ordering. In Proc. of the 17th International Conference on Architectural Support for Programming Languages and Operating Systems ASPLOS, 2012. DOI: 10.1145&#x2F;2150976.2151006. 32_</li>
<li>Gope and Lipasti<br>D. Gope and M. H. Lipasti. Atomic SC for simple in-order processors. In 20th IEEE International Symposium on High Performance Computer Architecture, 2014. DOI: 10.1109&#x2F;hpca.2014.6835950. 32</li>
<li>借助编译器或 MMU 的帮助<br>A. Singh, S. Narayanasamy, D. Marino, T.D Millstein, and M. Musuvathi. End-to-end sequential consistency. In 39th International Symposium on Computer Architecture, 2012. DOI: 10.1109&#x2F;isca.2012.6237045. 32</li>
</ol>
</blockquote>
<h1 id="SC-下的原子操作"><a href="#SC-下的原子操作" class="headerlink" title="SC 下的原子操作"></a>SC 下的原子操作</h1><p>原子操作用于多线程程序的同步，实现自旋锁或同步原语。</p>
<p>常用的原子指令为 read-modify-write(RMW) 包括：  </p>
<ol>
<li>test-and-set</li>
<li>fetch-and-increment</li>
<li>compare-and-swap</li>
</ol>
<p>在 SC 模型中， RMW 指令的 load 和 store 在 memory-order 上必须连续出现</p>
<h2 id="原子操作的实现"><a href="#原子操作的实现" class="headerlink" title="原子操作的实现"></a>原子操作的实现</h2><ol>
<li>naive 实现: 执行原子操作时锁住 memory system ，不允许其他核进行访存操作<ul>
<li>实现正确，直观，但牺牲了性能</li>
</ul>
</li>
<li>激进实现: 一个核将其 cache 中的某个 block 获取到 M 状态后对其进行连续的 load 和 store，且在 store 完成以前该 block 不能响应其他核的 coherence 请求</li>
<li>优化实现：一个核的 cache 如果有一个只读状态的 block ，先预测地 load 一次，再获取到该 block 的 M 状态时，执行 store ，并在 load 和 store 之间检查该 block 是否被踢出 cache<ul>
<li>如果被踢出，需要 squash 之前预测执行的 load</li>
</ul>
</li>
</ol>
<h1 id="实例：-MIPS-R10000"><a href="#实例：-MIPS-R10000" class="headerlink" title="实例： MIPS R10000"></a>实例： MIPS R10000</h1><ul>
<li>实现了 directory coherence protocol: MESI</li>
<li>系统总线最多连接 4 个核</li>
</ul>
<h2 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h2><ul>
<li>以 program order 将 load &#x2F; store 放入 address queue ，并预测发射执行</li>
<li>如果 address queue 中地址匹配， load 可以从 store 获得前递数据，否则从 dcache 中获取</li>
<li>如果 cache 中和 load 相关的 block 因为 coherence 失效或者冲突失效而被踢出时， load 之后的所有指令全部需要 squash 并重新执行</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://xixi-shredp.github.io">xixi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://xixi-shredp.github.io/2025/09/12/Arch/mem/consistency/SC/">https://xixi-shredp.github.io/2025/09/12/Arch/mem/consistency/SC/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/12/Arch/mem/consistency/TSO/" title="Total Store Order (TSO)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Total Store Order (TSO)</div></div><div class="info-2"><div class="info-item-1">处理器使用 write buffer 以掩盖 store miss 延迟，同时与 store 相关的 load 指令可以将 store 的写数据前递给 load 指令，使 load 指令更早得到数据。 write buffer 在 store-load 的情况下会违反 SC 模型，并且 write buffer 对多处理器可见 定义 第一次形式化提出:P. Sindhu, J.-M. Frailong, and M. Ceklov. Formal specification of memory models. Technical Report CSL-91–11, Xerox Palo Alto Research Center, December 1991. DOI: 10.1007&#x2F;978-1-4615-3604-8_2. 50  TSO execution 的要求:    所有核将自己的 load&#x2F;store 插入 global order &lt;m 的时候需满足各自的 program order &lt;p (不论访存地址是否相同) if L(a) &...</div></div></div></a><a class="pagination-related" href="/2025/09/12/Arch/mem/consistency/overview/" title="Memory Consistency And Cache Coherence"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Memory Consistency And Cache Coherence</div></div><div class="info-2"><div class="info-item-1">Consistency (A.K.A., Memory Consistency, Memory Consistency Model, or Memory Model)定义:在共享内存上执行的多线程程序所被允许的访存行为的规范。 对程序员可见 共享内存行为问题:    乱序 CPU 可能对访存顺序重新排序，这样的重排对于单核本身而言执行结果是正确的，但在多核中可能与其他核的访存顺序在并发执行时存在矛盾 并发执行的结果存在不确定性  这些不确定的执行结果可能是非预期的，但均没有违反 coherence 定义的 SWMR 不变性。 共享内存行为应当定义所有线程的所有执行。 内存一致性模型   Consistency Model Feature Implement Case    Sequential Consistency (SC) 最严格，最符合直觉 严格定序 MIPS R10K   Total Store Order (TSO) 性能有提升 使用 FIFO 保证写顺序 x86 and historical SPARC systems   relaxed&#x2F;weak memo...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xixi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">29</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xixi-shredp"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xixi-shredp" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my blog, for learning and communication purposes only. If there is any copyright infringement, please leave a message via email on GitHub.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.</span> <span class="toc-text">定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%90%E5%87%BA%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">第一次提出的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A5%E5%85%AC%E7%90%86%E7%9A%84%E5%BD%A2%E5%BC%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">以公理的形式定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Naive-Implementations"><span class="toc-number">2.1.</span> <span class="toc-text">Naive Implementations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81-Cache-Coherence-%E7%9A%84%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.2.</span> <span class="toc-text">支持 Cache Coherence 的基础实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81-Cache-Coherence-%E7%9A%84%E4%BC%98%E5%8C%96%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.</span> <span class="toc-text">支持 Cache Coherence 的优化实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-Binding-Prefetching"><span class="toc-number">2.3.1.</span> <span class="toc-text">Non-Binding Prefetching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Speculative-Cores"><span class="toc-number">2.3.2.</span> <span class="toc-text">Speculative Cores</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dynamically-Scheduled-Cores"><span class="toc-number">2.3.3.</span> <span class="toc-text">Dynamically Scheduled Cores</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Multithreading"><span class="toc-number">2.3.4.</span> <span class="toc-text">Multithreading</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Post-retirement-speculation"><span class="toc-number">2.3.5.</span> <span class="toc-text">Post-retirement speculation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Non-speculative-reordering"><span class="toc-number">2.3.6.</span> <span class="toc-text">Non-speculative reordering</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SC-%E4%B8%8B%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">SC 下的原子操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">原子操作的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A-MIPS-R10000"><span class="toc-number">4.</span> <span class="toc-text">实例： MIPS R10000</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">4.1.</span> <span class="toc-text">执行</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/06/os/generic/mm/" title="OS Virtual Memory Management">OS Virtual Memory Management</a><time datetime="2025-11-06T06:03:30.000Z" title="Created 2025-11-06 14:03:30">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/06/os/linux/riscv/boot/" title="Linux RISC-V Boot 流程">Linux RISC-V Boot 流程</a><time datetime="2025-11-06T01:44:36.000Z" title="Created 2025-11-06 09:44:36">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/04/os/linux/boot/" title="Linux Boot 过程">Linux Boot 过程</a><time datetime="2025-11-04T06:09:06.000Z" title="Created 2025-11-04 14:09:06">2025-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/04/os/generic/boot/init/" title="操作系统初始化">操作系统初始化</a><time datetime="2025-11-03T16:16:20.000Z" title="Created 2025-11-04 00:16:20">2025-11-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/03/os/generic/trap/" title="操作系统：Interupt, Exception, Syscall">操作系统：Interupt, Exception, Syscall</a><time datetime="2025-11-03T15:01:01.000Z" title="Created 2025-11-03 23:01:01">2025-11-03</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(160deg, #4D063C, #3E064D, #23064D, #08064D);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By xixi</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div><div class="footer_custom_text">Life is so Beautify!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>