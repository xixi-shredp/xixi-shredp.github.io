<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Cache Coherence Protocols | xixi's blog</title><meta name="author" content="xixi"><meta name="copyright" content="xixi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="cache 一致性协议简介">
<meta property="og:type" content="article">
<meta property="og:title" content="Cache Coherence Protocols">
<meta property="og:url" content="https://xixi-shredp.github.io/2025/09/14/Arch/cache/coherence/overview/index.html">
<meta property="og:site_name" content="xixi&#39;s blog">
<meta property="og:description" content="cache 一致性协议简介">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xixi-shredp.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-09-14T06:22:29.000Z">
<meta property="article:modified_time" content="2026-02-19T14:17:40.245Z">
<meta property="article:author" content="xixi">
<meta property="article:tag" content="CPU, Computer Architechture, OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xixi-shredp.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Cache Coherence Protocols",
  "url": "https://xixi-shredp.github.io/2025/09/14/Arch/cache/coherence/overview/",
  "image": "https://xixi-shredp.github.io/img/avatar.jpg",
  "datePublished": "2025-09-14T06:22:29.000Z",
  "dateModified": "2026-02-19T14:17:40.245Z",
  "author": [
    {
      "@type": "Person",
      "name": "xixi",
      "url": "https://xixi-shredp.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="https://xixi-shredp.github.io/2025/09/14/Arch/cache/coherence/overview/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Cache Coherence Protocols',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/default_top.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">30</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.svg" alt="Logo"><span class="site-name">xixi's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Cache Coherence Protocols</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Cache Coherence Protocols</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-09-14T06:22:29.000Z" title="Created 2025-09-14 14:22:29">2025-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-19T14:17:40.245Z" title="Updated 2026-02-19 22:17:40">2026-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/">Arch</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/cache/">cache</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/cache/coherence/">coherence</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="Baseline-System-Model"><a href="#Baseline-System-Model" class="headerlink" title="Baseline System Model"></a>Baseline System Model</h1><p><img src="/images/Arch/cache/coherence/overview/coherence_baseline.svg" alt="coherence_baseline"></p>
<p>每个 cache block 有两个 coherence 状态:  </p>
<ol>
<li>I(nvalid): 在 LLC 中表示所有的 cache 对于该 block 都是 I. </li>
<li>V(alid): 在 LLC 中表示有一个 cache 对于该 block 的状态是 V</li>
<li>$IV^D$ (瞬时状态): 状态 I 转换为 状态 V 的过程中的等待数据响应的瞬时状态</li>
</ol>
<p>bus messages:  </p>
<ol>
<li>Get: 请求一个 cache block</li>
<li>DataResp: 传输 block 的数据</li>
<li>Put: 将 block 写回到 memory controller</li>
</ol>
<p>cache controller 的行为:  </p>
<ol>
<li>发生 load&#x2F;store miss 时， 触发一次 Get transaction: 发送一个 Get message 并等待响应的 DataResp message(该 transaction 是原子的，等待响应过程中不可有其他 transaction)</li>
<li>Evict Block 时，发送 Put message</li>
</ol>
<p><img src="/images/Arch/cache/coherence/overview/simple_protocols.svg" alt="simple_protocols"></p>
<p>Cache controller specification:  </p>
<table>
	<tr align="center">
      <td rowspan="3">States</td>
	    <td rowspan="2" colspan="2">Core Events</td>
	    <td colspan="6">BusEvents</td>
	</tr>
	<tr align="center">
	    <td colspan="3">Message for Own Transactions</td>
	    <td colspan="3">Message for Other Cores' Transactions</td>
	</tr>
	<tr align="center">
	    <td>Load / Store</td>
	    <td>Evict Block</td>
	    <td>Own-Get</td>
	    <td>DataResp for Own-Get</td>
	    <td>Own-Put</td>
	    <td>Other-Get</td>
	    <td>DataResp for Other-Get</td>
	    <td>Other-Put</td>
	</tr>
	<tr>
	    <td>I</td>
	    <td>Issue Get / IV^D</td>
	    <td></td>
	    <td></td>
	    <td></td>
	    <td></td>
	    <td></td>
	    <td></td>
	    <td></td>
	</tr>
	<tr>
	    <td>IV^D</td>
	    <td>Stall Load and Store</td>
	    <td>Stall Evict</td>
	    <td></td>
	    <td>Copy data into cache ,perform Load or Store / V </td>
	    <td></td>
	    <td></td>
	    <td></td>
	    <td></td>
	</tr>
	<tr>
	    <td>V</td>
	    <td>Perform Load or Store</td>
	    <td>Issue Put / I</td>
	    <td></td>
	    <td></td>
	    <td></td>
	    <td>Send DataResp / I</td>
	    <td></td>
	    <td></td>
	</tr>
</table>

<p>Memory controller specification:  </p>
<table>
	<tr align="center">
      <td rowspan="2">States</td>
	    <td colspan="2">BusEvents</td>
	</tr>
	<tr align="center">
	    <td>Get</td>
	    <td>Put</td>
	</tr>
	<tr>
	    <td>I</td>
	    <td>Send data block in DataResp message to requestor / V</td>
	    <td></td>
	</tr>
	<tr>
	    <td>V</td>
	    <td></td>
	    <td>Update data block in memory / I</td>
	</tr>
</table>

<ul>
<li>优点: 简单</li>
<li>缺点: 不够高效</li>
</ul>
<h1 id="Cache-Coherence-Protocols-设计空间"><a href="#Cache-Coherence-Protocols-设计空间" class="headerlink" title="Cache Coherence Protocols 设计空间"></a>Cache Coherence Protocols 设计空间</h1><p>选择因素：  </p>
<ol>
<li>stable states 稳定状态: 和其余因素, protocols 本身的实现独立</li>
<li>transaction : 和特定的 protocol 独立</li>
<li>events</li>
<li>transitions</li>
</ol>
<blockquote>
<p>stable states 和 transaction 与具体的 protocols 独立，而 events 和 transitions 则高度依赖于 coherence protocols</p>
</blockquote>
<h2 id="States"><a href="#States" class="headerlink" title="States"></a>States</h2><p>单核系统:<br>只需要两个状态： valid, invalid (对于 write-back cache, 还需要 dirty 标记是否是脏块)</p>
<p>多核系统，有四个需要被编码的特征：  </p>
<ol>
<li>Validity: valid block 并且拥有该 block 最新的值，可读 ，在 exclusive 时还可写</li>
<li>Dirtiness: 同单核系统一致, block 被写入新数据，而下级 Cache 保留的是写入之前的数据时为 dirty</li>
<li>Exclusivity: 当 block 为系统中唯一的私有 cache 的 block 副本 (其他同级 cache 没有该 block)时，称该 block exclusive.</li>
<li>Ownership: coherence controller 为一个 block 的 owner 当该 controller 负责响应针对该 block 的请求 <ul>
<li>在大多数 protocols 中，一个给定的 block 只有一个 owner</li>
<li>owner 中的 block 不会由于冲突被替换出 cache</li>
</ul>
</li>
</ol>
<h3 id="Cache-Block-States"><a href="#Cache-Block-States" class="headerlink" title="Cache Block States"></a>Cache Block States</h3><h4 id="Stable-States-稳定状态"><a href="#Stable-States-稳定状态" class="headerlink" title="Stable States 稳定状态"></a>Stable States 稳定状态</h4><p>大多数 coherence protocols 使用的 stable states 都是 MOESI 状态的子集，最基础的状态为 MSI 状态。</p>
<p><strong>M(odified)</strong>:<br>    block 处于 valid, exclusive, owned, potentially dirty等状态, block 可能被读写， 当前 cache 拥有该 block 唯一 valid 副本(exclusive), cache 必须响应对该 block 的请求(owned), LLC 中关于该 block 的数据也可能已过时(potentially dirty)。</p>
<p><strong>O(wned)</strong>:<br>    block 处于 valid, owned, potentially dirty等状态, 但是 not exclusive, 当前 cache 拥有该 block 的只读副本，其他 cache 可能也有只读副本，但他们不是 owner，cache 必须响应对该 block 的请求(owned), LLC 中关于该 block 的数据也可能已过时(potentially dirty)。</p>
<p><strong>E(xclusive)</strong>:<br>    block 处于 valid, exclusive, clean等状态, block 可能被读写， 当前 cache 拥有该 block 唯一 valid 只读副本(exclusive), LLC 中关于该 block 的数据也是最新的(clean)。</p>
<p><strong>S(hared)</strong>:<br>    block valid,但是 not exclusive, not owned, not dirty, 当前 cache 拥有该 block 的只读副本（其他 cache 可能也有）</p>
<p><strong>I(nvalid)</strong>:<br>    block invalid. 当前 cache 要么不包含该 block ，要么包含该 block 的过时的数据（不可读写）</p>
<p><img src="/images/Arch/cache/coherence/overview/moesi_state.svg" alt="moesi_state"></p>
<p>在具体的系统实现中，每个 cache line 都需要增加相应的 field bits 以维护 coherence state</p>
<blockquote>
<p><strong>MOESI 状态第一次提出</strong>:<br>P. Sweazey and A. J. Smith. A class of compatible cache consistency protocols and their support by the IEEE Futurebus. In Proc. of the 13th Annual International Symposium on Computer Architecture, pp. 414–423, June 1986. DOI: 10.1145&#x2F;17356.17404. 97, 98</p>
</blockquote>
<h4 id="Transient-States-瞬时状态"><a href="#Transient-States-瞬时状态" class="headerlink" title="Transient States 瞬时状态"></a>Transient States 瞬时状态</h4><p>从一个 stable state 转换到另一个 stable state 的过程中会存在 transient state 瞬时状态，记为 $XY^Z$ 表示状态在从 X 状态转换为 Y 状态的过程中直到事件 Z 发生转换结束。</p>
<p>在具体的系统实现中，也需要相应的 field bits 以维护这些 transient states ，但是往往通过 MSHRs 或者类似的结构来追踪瞬时状态</p>
<h3 id="LLC-Memory-Block-States"><a href="#LLC-Memory-Block-States" class="headerlink" title="LLC&#x2F;Memory Block States"></a>LLC&#x2F;Memory Block States</h3><p>有两种约定方式：  </p>
<ol>
<li>LLC&#x2F;Memory Block State 是 Cache Block State 的聚合<ul>
<li>如果所有 cache 中该 block 都处于 I 状态， 那么该块在 LLC&#x2F;Memory 中的状态也为 I</li>
<li>如果有一个 cache 中该 block 处于 S 状态， 那么该块在 LLC&#x2F;Memory 中的状态为 S</li>
<li>如果只有一个 cache 中存在该 block 且处于 M 状态， 那么该块在 LLC&#x2F;Memory 中的状态为 M</li>
</ul>
</li>
<li>LLC&#x2F;Memory Block State 对应 memory controller 对 block 的访问权限 <ul>
<li>如果所有 cache 中该 block 都处于 I 状态， 那么该块在 LLC&#x2F;Memory 中的状态为 O</li>
<li>如果有一个 cache 中该 block 处于 S 状态， 那么该块在 LLC&#x2F;Memory 中的状态为 O</li>
<li>如果只有一个 cache 中存在该 block 且处于 M 状态或者 O 状态， 那么该块在 LLC&#x2F;Memory 中的状态为 I</li>
</ul>
</li>
</ol>
<p>对于单个多核芯片下的 inclusive LLC ，并不需要显式地指定 coherence state ，如果 block 不在 LLC 中，隐式状态为 I. 但对于多个多核芯片，则需要显示指定 LLC 的 coherence states.</p>
<blockquote>
<p><strong>多核芯片出现以前对于 memory block state 的维护</strong>:  </p>
<ol>
<li>Augment Each Block of Memory with State Bits<ul>
<li>为每个 cache block 增加额外的 bits 以维护 coherence states</li>
<li>优点：通用且直观</li>
<li>缺点：<ul>
<li>带来一定的存储开销 (可以通过维护更大的 block 粒度比如 512 bits 来减少存储开销)</li>
<li>每次获取 coherence state 都需要访问一次内存，延时较大</li>
<li>所有的状态转换都需要内存 (DRAM) 进行一次 “读-修改-写” 会影响 DRAM 的功耗和带宽</li>
</ul>
</li>
</ul>
</li>
<li>Add Single State Bit per Block at Memory<ul>
<li>仅仅使用两个状态 valid and invalid (1 bit) 来维护 coherence state</li>
</ul>
</li>
<li>Zero-bit logical OR<ul>
<li>通过所有 cache 对于某个 block 的 coherence state 聚合起来表示 memory 对于该 block 的状态</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="Transactions-状态转换事件"><a href="#Transactions-状态转换事件" class="headerlink" title="Transactions 状态转换事件"></a>Transactions 状态转换事件</h2><p>大部分 protocols 采用的是相同的 transactions</p>
<p>Common Transactions from Cache Controller:  </p>
<table>
<thead>
<tr>
<th>Transaction</th>
<th>Goal of Requestor</th>
</tr>
</thead>
<tbody><tr>
<td>GetShared (GetS)</td>
<td>Obtain block in Shared (read-only) state</td>
</tr>
<tr>
<td>GetModified (GetM)</td>
<td>Obtain block in Modified (read-only) state</td>
</tr>
<tr>
<td>Upgrade (Upg)</td>
<td>Upgrade block state from read-only (Shared or Owned) to read-write (Modi</td>
</tr>
<tr>
<td>PutShared (PutS)</td>
<td>Evict block in Shared state</td>
</tr>
<tr>
<td>PutExclusive (PutE)</td>
<td>Evict block in Exclusive state</td>
</tr>
<tr>
<td>PutOwned (PutO)</td>
<td>Evict block in Owned state</td>
</tr>
<tr>
<td>PutModified (PutM)</td>
<td>Evict block in Modified state</td>
</tr>
</tbody></table>
<p>Common core requests to Cache Controller:  </p>
<table>
<thead>
<tr>
<th>Event</th>
<th>Response of (Typical) Cache Controller</th>
</tr>
</thead>
<tbody><tr>
<td>Load</td>
<td>cache hit 则使用来自 cache 的数据响应; 否则生成 GetS transaction</td>
</tr>
<tr>
<td>Store</td>
<td>cache hit in state E &#x2F; M, 将数据写入 cache; 否则生成 GetM &#x2F; Upg transaction</td>
</tr>
<tr>
<td>Atomic read-modify-write</td>
<td>cache hit in state E &#x2F; M , 则原子地执行 RMW 操作; 否则生成 GetM &#x2F; Upg transaction</td>
</tr>
<tr>
<td>Instruction fetch</td>
<td>cache hit (in I-cache), 使用来自 cache 的指令响应; 否则生成  GetS transaction</td>
</tr>
<tr>
<td>Read-only  prefetch</td>
<td>cache hit, 忽略; 否则可能有选择地生成 GetS transaction</td>
</tr>
<tr>
<td>Read-Write prefetch</td>
<td>cache hit in state M, 忽略; 否则可能有选择地生成 GetM &#x2F; Upg transaction</td>
</tr>
<tr>
<td>Replacement</td>
<td>取决于 block 的状态, 生成 PutS &#x2F; PutE &#x2F; PutO &#x2F; PutM transaction</td>
</tr>
</tbody></table>
<h2 id="Protocols-Design"><a href="#Protocols-Design" class="headerlink" title="Protocols Design"></a>Protocols Design</h2><p>coherence protocols 主要有两大类:  </p>
<ol>
<li>Snooping protocol<ul>
<li>cache controller 通过向所有其他 coherence controller 广播请求来生成针对某一个 block 的请求</li>
<li>通过共享总线互联网络实现广播，要求总线上请求满足 total order</li>
<li>逻辑简单，但 not scalable</li>
</ul>
</li>
<li>Directory protocol<ul>
<li>cache controller 通过将请求单播给某一个 block 所属的 memory controller 来生成针对该 block 的请求</li>
<li>memory controller 维护一个目录来管理识别所有 block 的 owner 和 sharers</li>
<li>scalable 但请求延时较长，会发送额外的 message##</li>
</ul>
</li>
<li>Hybrid Designs<ul>
<li>P. Conway and B. Hughes. The AMD Opteron northbridge architecture. IEEE Micro, 27(2):10–21, March&#x2F;April 2007. DOI: 10.1109&#x2F;mm.2007.43. 105</li>
<li>M. M. K. Martin, D. J. Sorin, M. D. Hill, and D. A. Wood. Bandwidth adaptive snooping. In Proc. of the 8th IEEE Symposium on High-Performance Computer Architecture, pp. 251262, January 2002. DOI: 10.1109&#x2F;hpca.2002.995715. 105</li>
</ul>
</li>
</ol>
<p>根据 core 如何写入 block, 也可以分为两类:  </p>
<ol>
<li>Invalidate protocol<ul>
<li>一个 core 写入一个 block 时，生成 transaction 将其他所有核响应的 block 都invalidate </li>
<li>实现更简单</li>
</ul>
</li>
<li>Update protocol<ul>
<li>一个 core 写入一个 block 时，生成 transaction 将新值更新到其他所有核的 block 中</li>
<li>其他核读取新值的延时会降低，不需要再重新请求 block</li>
<li>会消耗大量的带宽 (update message 要比 invalidate message 要大)</li>
<li>实现更加困难（写原子性的保证更难实现）</li>
</ul>
</li>
<li>Hybrid Designs<ul>
<li>A. Raynaud, Z. Zhang, and J. Torrellas. Distance-adaptive update protocols for scalable shared-memory multiprocessors. In Proc. of the 2nd IEEE Symposium on High-Performance Computer Architecture, February 1996. DOI: 10.1109&#x2F;hpca.1996.501197. 105</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://xixi-shredp.github.io">xixi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://xixi-shredp.github.io/2025/09/14/Arch/cache/coherence/overview/">https://xixi-shredp.github.io/2025/09/14/Arch/cache/coherence/overview/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/14/Arch/cache/coherence/snooping/" title="Snooping Coherence Protocols"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">Snooping Coherence Protocols</div></div><div class="info-2"><div class="info-item-1">snooping 协议的基本想法：所有的 coherence 控制器观测到的 coherence 请求的顺序是相同的 各 coherence 控制器对某个 block 观测到的请求顺序不一致可能导致：    可能违反 SWMR 不变性的要求 可能导致死锁（没有控制器认为自己是 owner ，因此 coherence 请求不会收到响应）  通过获取按序达到的给定 block 的所有请求， snooping 系统可以使能分布式 coherence 控制器来正确更新有限状态机 传统 snooping 系统    广播请求到所有的 coherence 控制器 coherence 请求通过有序广播网络传播，如总线 互联网络必须串行化请求以实现 total order 总线可以通过仲裁逻辑保证总线上只有一个请求 发出请求后控制器需要观察其他控制器接受到的请求来判断所发送的请求在 total order 中的位置     针对所有的 blocks 创建一个 total order coherence 本身只要求每个 block 请求的顺序 更容易实现 SC &#x2F; TSO 等要求 tot...</div></div></div></a><a class="pagination-related  no-desc" href="/2025/09/14/Arch/cache/replacement/coarse/recency-based/" title="Recency-Based Cache Replacement Policies"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Recency-Based Cache Replacement Policies</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xixi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">30</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xixi-shredp"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xixi-shredp" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my blog, for learning and communication purposes only. If there is any copyright infringement, please leave a message via email on GitHub.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Baseline-System-Model"><span class="toc-number">1.</span> <span class="toc-text">Baseline System Model</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Cache-Coherence-Protocols-%E8%AE%BE%E8%AE%A1%E7%A9%BA%E9%97%B4"><span class="toc-number">2.</span> <span class="toc-text">Cache Coherence Protocols 设计空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#States"><span class="toc-number">2.1.</span> <span class="toc-text">States</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cache-Block-States"><span class="toc-number">2.1.1.</span> <span class="toc-text">Cache Block States</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Stable-States-%E7%A8%B3%E5%AE%9A%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">Stable States 稳定状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transient-States-%E7%9E%AC%E6%97%B6%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">Transient States 瞬时状态</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LLC-Memory-Block-States"><span class="toc-number">2.1.2.</span> <span class="toc-text">LLC&#x2F;Memory Block States</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactions-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.2.</span> <span class="toc-text">Transactions 状态转换事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Protocols-Design"><span class="toc-number">2.3.</span> <span class="toc-text">Protocols Design</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/12/Arch/simulator/gem5/iew/" title="Gem5: Dispatch">Gem5: Dispatch</a><time datetime="2026-02-12T09:49:07.000Z" title="Created 2026-02-12 17:49:07">2026-02-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/11/Arch/simulator/gem5/prefetch/" title="Gem5 Prefetcher">Gem5 Prefetcher</a><time datetime="2026-02-11T15:56:47.000Z" title="Created 2026-02-11 23:56:47">2026-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/06/os/generic/mm/" title="OS Virtual Memory Management">OS Virtual Memory Management</a><time datetime="2025-11-06T06:03:30.000Z" title="Created 2025-11-06 14:03:30">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/06/os/linux/riscv/boot/" title="Linux RISC-V Boot 流程">Linux RISC-V Boot 流程</a><time datetime="2025-11-06T01:44:36.000Z" title="Created 2025-11-06 09:44:36">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/04/os/linux/boot/" title="Linux Boot 过程">Linux Boot 过程</a><time datetime="2025-11-04T06:09:06.000Z" title="Created 2025-11-04 14:09:06">2025-11-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(160deg, #4D063C, #3E064D, #23064D, #08064D);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By xixi</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div><div class="footer_custom_text">Life is so Beautify!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>