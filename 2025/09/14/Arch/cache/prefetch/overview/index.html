<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Hardware Cache Prefetcher | xixi's blog</title><meta name="author" content="xixi"><meta name="copyright" content="xixi"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="硬件 cache 预取器简介">
<meta property="og:type" content="article">
<meta property="og:title" content="Hardware Cache Prefetcher">
<meta property="og:url" content="https://xixi-shredp.github.io/2025/09/14/Arch/cache/prefetch/overview/index.html">
<meta property="og:site_name" content="xixi&#39;s blog">
<meta property="og:description" content="硬件 cache 预取器简介">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://xixi-shredp.github.io/img/avatar.jpg">
<meta property="article:published_time" content="2025-09-14T08:37:45.000Z">
<meta property="article:modified_time" content="2026-02-19T14:52:31.515Z">
<meta property="article:author" content="xixi">
<meta property="article:tag" content="CPU, Computer Architechture, OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xixi-shredp.github.io/img/avatar.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Hardware Cache Prefetcher",
  "url": "https://xixi-shredp.github.io/2025/09/14/Arch/cache/prefetch/overview/",
  "image": "https://xixi-shredp.github.io/img/avatar.jpg",
  "datePublished": "2025-09-14T08:37:45.000Z",
  "dateModified": "2026-02-19T14:52:31.515Z",
  "author": [
    {
      "@type": "Person",
      "name": "xixi",
      "url": "https://xixi-shredp.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.svg"><link rel="canonical" href="https://xixi-shredp.github.io/2025/09/14/Arch/cache/prefetch/overview/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.13.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Hardware Cache Prefetcher',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"></head><body><div class="bg-animation" id="web_bg" style="background-image: url(/img/default_top.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">30</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/default_top.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/favicon.svg" alt="Logo"><span class="site-name">xixi's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Hardware Cache Prefetcher</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Hardware Cache Prefetcher</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-09-14T08:37:45.000Z" title="Created 2025-09-14 16:37:45">2025-09-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-19T14:52:31.515Z" title="Updated 2026-02-19 22:52:31">2026-02-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/">Arch</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/cache/">cache</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Arch/cache/prefetch/">prefetch</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>硬件预取的任务:  </p>
<ol>
<li>预测访存地址 (决定:精确率 accuracy) 取决于：<ul>
<li>程序本身的访存行为</li>
<li>在 cache 层级结构中的哪个层次进行预取<ul>
<li>L1 可以捕获所有的访存，精确度高，但浪费资源（ L1 一般会 hit ，不需要预取，会浪费大量的预取资源）</li>
<li>低层级 cache 捕获的访存请求少</li>
</ul>
</li>
<li>cache placement 和 replacement 策略</li>
</ul>
</li>
<li>预测何时预取 (决定:及时性 timely)<ul>
<li>太早：可能会踢出处理器此时需要先使用的 cache block</li>
<li>太晚：可能由于访存延时导致迟迟得不到预取的结果</li>
</ul>
</li>
<li>决定如何放置预取数据<ul>
<li>binding prefetch ：预取到寄存器<ul>
<li>浪费寄存器资源</li>
<li>即使此时访存负载很高，依旧会强制预取</li>
<li>语义错误（预取无效地址会触发 page fault）</li>
<li>不能应用到指令预取</li>
</ul>
</li>
<li>non-binding prefetch：预取到 cache 或者 buffer 中<ul>
<li>这些 cache 和 buffer 同样需要参与一致性协议</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>预取策略的评估指标 (trade-off)  </p>
<ol>
<li>Coverage 覆盖率: 在处理器显式的访存请求中，预测成功的占比</li>
<li>Accuracy 精确度: 实际发射的访存请求中，预取有用的占比</li>
</ol>
</blockquote>
<h1 id="指令预取-Instruction-Prefetching"><a href="#指令预取-Instruction-Prefetching" class="headerlink" title="指令预取 Instruction Prefetching"></a>指令预取 Instruction Prefetching</h1><ol>
<li>更适用于大规模指令工作负载，如服务器和云工作负载。（桌面应用程序和科学计算的工作负载相比之下指令规模并不大）</li>
<li>CPU 内部的乱序执行只能 overlap 数据访存的延时，对于指令访存则起不了太大作用</li>
</ol>
<p>现有预取器对比:  </p>
<table>
<thead>
<tr>
<th>预取器</th>
<th>Accuracy</th>
<th>Cost</th>
</tr>
</thead>
<tbody><tr>
<td><a href="#nextline-prefetch">Next-Line Prefetching</a></td>
<td>50%</td>
<td>&lt; 1 KB</td>
</tr>
<tr>
<td><a href="#FDP">Fetch-Directed Prefetching</a></td>
<td>&gt; 50%</td>
<td>&lt; 1 KB</td>
</tr>
<tr>
<td><a href="#discontinuity-prefetch">Discontinuity Prefetching</a></td>
<td>&gt; 50%</td>
<td>&gt; 1 KB</td>
</tr>
<tr>
<td><a href="#prescient-fetch">Prescient Fetch</a></td>
<td>&gt; 50%</td>
<td>&gt; 1 KB</td>
</tr>
<tr>
<td><a href="#TIFS">Temporal Instruction Fetch Streaming (TIFS)</a></td>
<td>95%</td>
<td>~ 64 KB&#x2F;core</td>
</tr>
<tr>
<td><a href="#RDIP">Return-address stack-Directed Instruction Prefetching (RDIP)</a></td>
<td>&gt; 95%</td>
<td>~ 64 KB&#x2F;core</td>
</tr>
<tr>
<td><a href="#proactive-IF">Proactive Instruction Fetch</a></td>
<td>&gt; 99%</td>
<td>~ 256 KB&#x2F;core</td>
</tr>
</tbody></table>
<h2 id="Next-Line-Prefetching"><a href="#Next-Line-Prefetching" class="headerlink" title="Next-Line Prefetching"></a>Next-Line Prefetching</h2><p><a id="nextline-prefetch"></a></p>
<blockquote>
<p>A. J. Smith. “Sequential Program Prefetching in Memory Hierarchies.” Computer, v. 11, no. 12, 1978. DOI: 10.1109&#x2F;C-M.1978.218016. 7, 15</p>
</blockquote>
<p>最简单，顺序预取，适用于顺序指令流的场景</p>
<p><img src="/2025/09/14/Arch/cache/prefetch/overview/nextline.svg" alt="nextline"></p>
<ol>
<li>从下级 cache 预取到的指令被放入 Stream buffer(一个小的全相联 buffer)</li>
<li>当 Stream buffer 中的一条指令被处理器请求取走时，该指令转移到 cache 中并向下级 cache 发起下一次预取</li>
</ol>
<p>第一个实现的机器为 <em>IBM System&#x2F;360 Model 91</em></p>
<blockquote>
<p>扩展: 将每次预取的长度扩展为连续的基本块  </p>
<ol>
<li>A. Ramirez, O. J. Santana, J. L. Larriba-Pey and M. Valero. “Fetching Instruction  Streams.” In Proc. of the 35th Annual ACM&#x2F;IEEE International Symposium on Microarchitecture, 2002. 8</li>
<li>O. J. Santana, A. Ramirez, and M. Valero. “Enlarging Instruction Streams.” IEEE Transactions on Computers, v. 56, no. 10, 2007. DOI: 10.1109&#x2F;TC.2007.70742. 8, 11</li>
</ol>
</blockquote>
<h2 id="Fetch-Directed-Prefetching"><a href="#Fetch-Directed-Prefetching" class="headerlink" title="Fetch-Directed Prefetching"></a>Fetch-Directed Prefetching</h2><p><a id="FDP"></a></p>
<p>Branch-predictor-directed prefetchers: 利用分支预测器以探索指令流的变化  </p>
<blockquote>
<ol>
<li>I-C. K. Chen, C-C. Lee, and T. N. Mudge. “Instruction Prefetching Using Branch Prediction Information.” In Proc. of the IEEE International Conference on Computer Design, 1997. DOI: 10.1109&#x2F;ICCD.1997.628926. 9</li>
<li><strong>G. Reinman, B. Calder, and T. Austin. “Fetch Directed Instruction Prefetching.” In Proc. of the 32nd Annual ACM&#x2F;IEEE International Symposium on Microarchitecture, 1999. 9</strong></li>
<li>A. V. Veidenbaum, Q. Zhao, and A. Shameer. “Non-Sequential Instruction Cache Prefetching for Multiple–Issue Processors.” International Journal of High Speed Computing, v. 10, no. 1, 1999. DOI: 10.1142&#x2F;S0129053399000065. 9</li>
<li>R. Panda, P. V. Gratz, and D. A. Jiménez. “B-Fetch: Branch Prediction Directed Prefetching for In-Order Processors.” In Proc. of the 18th International Symposium on High-Performance Computer Architecture, 2012. DOI: 10.1109&#x2F;L-CA.2011.33. 9</li>
<li>T. Sherwood, S. Sair, and B. Calder. “Predictor-Directed Stream Buffers.” In Proc. of the 33rd Annual ACM&#x2F;IEEE International Symposium on Microarchitecture, 2000. DOI: 10.1145&#x2F;360128.360135. 9</li>
</ol>
</blockquote>
<h3 id="Fetch-Directed-Instruction-Prefetching-FDIP"><a href="#Fetch-Directed-Instruction-Prefetching-FDIP" class="headerlink" title="Fetch-Directed Instruction Prefetching (FDIP)"></a>Fetch-Directed Instruction Prefetching (FDIP)</h3><p><img src="/2025/09/14/Arch/cache/prefetch/overview/fdip.svg" alt="fdip"></p>
<ul>
<li>将分支预测器从 IFU 中解耦出来，并在二者之间引入 <em>fetch target queue</em> (FTQ)</li>
<li>预取器使用 FTQ 中的地址从 L2 Cache 中预取指令块，并放入一个小的全相联 buffer : <em>Prefetch Buffer</em></li>
<li>IFU 会并行访问 Prefetch Buffer 和 L1 ICache</li>
<li>L1 ICache 中空闲的端口还会监测 Prefetch Buffer 中是否有相应的指令块以避免二者之间存储冗余的指令块</li>
<li>L1 ICache 会将 miss 的地址放入 <em>prefetch instruction queue</em> (PIQ) 以准备预取</li>
</ul>
<p>limit:  在所有的指令 cache miss 中有将近一半需要超过 16 个连续的正确分支预测才能生成候选的预取地址 (统计数据)</p>
<h2 id="Discontinuity-Prefetching"><a href="#Discontinuity-Prefetching" class="headerlink" title="Discontinuity Prefetching"></a>Discontinuity Prefetching</h2><p><a id="discontinuity-prefetch"></a></p>
<p>定位于处理指令序列中的不连续性：函数调用、跳转分支、 traps</p>
<table>
	<tr align="center">
      <td>Prefetcher </td>
      <td>From </td>
	    <td>Features </td>
	</tr>
	<tr>
	    <td>Wrong-Path  Prefetching</td>
	    <td>J. Pierce, and T. N. Mudge. “Wrong-Path Instruction Prefetching.” In Proc. of the 29th Annual ACM/IEEE International Symposium on Microarchitecture, 1996. 11</td>
	    <td>解决 FDIP 中对于分支未跳转路径的处理问题（这条路径之后很可能会被使用）</td>
	</tr>
	<tr>
	    <td>Branch-History Guided Prefetcher</td>
	    <td>V. Srinivasan, E. S. Davidson, G. S. Tyson, M. J. Charney, and T. R. Puzak. “Branch History Guided Instruction Prefetching.” In Proc. of the 7th International Symposium on High-Performance Computer Architecture, 2001. DOI: 10.1109/HPCA.2001.903271. 11</td>
	    <td rowspan="5">根据更早的指令预测不连续的指令流（使用分支预测器追踪）</td>
	</tr>
	<tr>
	    <td>Execution-History Guided Prefetcher</td>
	    <td>Y. Zhang, S. Haga, and R. Barua. “Execution History Guided Instruction Prefetching.” In Proc. of the 16th Annual International Conference on Supercomputing, 2002. DOI: 10.1145/514191.514220. 11</td>
	</tr>
	<tr>
	    <td>Multiple-Stream Predictor</td>
	    <td>O. J. Santana, A. Ramirez, and M. Valero. “Enlarging Instruction Streams.” IEEE Transactions on Computers, v. 56, no. 10, 2007. DOI: 10.1109/TC.2007.70742. 8, 11</td>
	</tr>
	<tr>
	    <td>Next-Trace Predictors</td>
	    <td>Q. Jacobson, E. Rotenberg, and J. E. Smith. “Path-Based Next Trace Prediction.” In Proc. of the 30th Annual ACM/IEEE International Symposium on Microarchitecture, 1997. DOI: 10.1109/MICRO.1997.645793. 11</td>
	</tr>
	<tr>
	    <td>Call Graph Prefetching (对服务器应用程序很有效果)</td>
	    <td>M. Annavaram, J. M. Patel, and E. S. Davidson. “Call Graph Prefetching for Database Applications.” ACM Transactions on Computer Systems, v. 21, no. 4, 2003. DOI: 10.1145/945506.945509. 11</td>
	</tr>
	<tr>
	    <td><a href="#DiscontinuityPredictor">DiscontinuityPredictor</a></td>
	    <td></td>
	    <td></td>
	</tr>
</table>

<h3 id="Discontinuity-Predictor"><a href="#Discontinuity-Predictor" class="headerlink" title="Discontinuity Predictor"></a>Discontinuity Predictor</h3><p><a id = "DiscontinuityPredictor"></a></p>
<p>Recent Example</p>
<blockquote>
<p>L. Spracklen, Y. Chou, and S. G. Abraham. “Effective Instruction Prefetching in Chip Multiprocessors for Modern Commercial Applications.” In Proc. of the 11th International Symposium on High-Performance Computer Architecture, 2005. DOI: 10.1109&#x2F; HPCA.2005.13. 11</p>
</blockquote>
<p><img src="/2025/09/14/Arch/cache/prefetch/overview/discontinuity_predictor.svg" alt="discontinuity_predictor"></p>
<ul>
<li>维护一张表示取指不连续性的表： discontinuity table<ul>
<li>包含 被预测为跳转的分支的基本块的 PC 到分支目标地址的映射 (只预测一个分支跳转目标)</li>
</ul>
</li>
<li>IFU 取指时，查询 discontinuity table <ul>
<li>如果地址匹配，除了顺序预取外，还预取不连续路径</li>
</ul>
</li>
<li>简单且硬件开销很小</li>
<li>只能跨越单一的取指不连续性<ul>
<li>递归查询以探索其他路径会导致预取的基本块数量呈指数增长</li>
<li>限制最多跨越一次不连续性会限制预取器的预测能力</li>
</ul>
</li>
<li>覆盖率有限<ul>
<li>因为对于每个 cache block 该表只会记录单一不连续性，而实际情况下一个指令块内可能包含多个跳转分支</li>
</ul>
</li>
</ul>
<h2 id="Prescient-Fetch"><a href="#Prescient-Fetch" class="headerlink" title="Prescient Fetch"></a>Prescient Fetch</h2><p><a id="prescient-fetch"></a></p>
<p>todo…</p>
<h2 id="Temporal-Instruction-Fetch-Streaming-TIFS"><a href="#Temporal-Instruction-Fetch-Streaming-TIFS" class="headerlink" title="Temporal Instruction Fetch Streaming (TIFS)"></a>Temporal Instruction Fetch Streaming (TIFS)</h2><p><a id="TIFS"></a></p>
<p>todo…</p>
<h2 id="Return-address-stack-Directed-Instruction-Prefetching-RDIP"><a href="#Return-address-stack-Directed-Instruction-Prefetching-RDIP" class="headerlink" title="Return-address stack-Directed Instruction Prefetching (RDIP)"></a>Return-address stack-Directed Instruction Prefetching (RDIP)</h2><p><a id="RDIP"></a></p>
<p>todo…</p>
<h2 id="Proactive-Instruction-Fetch"><a href="#Proactive-Instruction-Fetch" class="headerlink" title="Proactive Instruction Fetch"></a>Proactive Instruction Fetch</h2><p><a id="proactive-IF"></a></p>
<p>todo…</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ol>
<li>A Primer on Hardware Prefetching</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://xixi-shredp.github.io">xixi</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://xixi-shredp.github.io/2025/09/14/Arch/cache/prefetch/overview/">https://xixi-shredp.github.io/2025/09/14/Arch/cache/prefetch/overview/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/09/18/os/generic/fs/file_system/" title="文件系统 File System"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">文件系统 File System</div></div><div class="info-2"><div class="info-item-1">文件系统API文件（file）低级名称：inode 号（inode number） 内容：vector&lt;char&gt;  文件描述符（file descriptor）: 指向操作系统对象的指针通过指针可以访问 “everything”，是一个整数，每个进程私有 与其他系统调用的交互：  fork 时会被子进程继承 execve 时文件描述符不变  文件偏移（offset）: 文件的读写自带 “游标”Offset 管理：  read&#x2F;write: 会自动维护 offset lseek: 修改 offset 位置  与其他系统调用的交互：  open 时，获得一个独立的 offset dup 时，两个文件描述符共享 offset fork 时，父子进程共享 offset (UNIX)  文件syscall API 创建文件：open() 构建一个数据结构（inode） 将人类可读的名称链接到该文件 将该链接放入目录中   读写文件 read() &amp; write() 修改偏移量：lseek() 强制立即写入fsync()出于性能的原因，write()在内存中会...</div></div></div></a><a class="pagination-related" href="/2025/09/14/Arch/cache/coherence/snooping/" title="Snooping Coherence Protocols"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">Snooping Coherence Protocols</div></div><div class="info-2"><div class="info-item-1">snooping 协议的基本想法：所有的 coherence 控制器观测到的 coherence 请求的顺序是相同的 各 coherence 控制器对某个 block 观测到的请求顺序不一致可能导致：    可能违反 SWMR 不变性的要求 可能导致死锁（没有控制器认为自己是 owner ，因此 coherence 请求不会收到响应）  通过获取按序达到的给定 block 的所有请求， snooping 系统可以使能分布式 coherence 控制器来正确更新有限状态机 传统 snooping 系统    广播请求到所有的 coherence 控制器 coherence 请求通过有序广播网络传播，如总线 互联网络必须串行化请求以实现 total order 总线可以通过仲裁逻辑保证总线上只有一个请求 发出请求后控制器需要观察其他控制器接受到的请求来判断所发送的请求在 total order 中的位置     针对所有的 blocks 创建一个 total order coherence 本身只要求每个 block 请求的顺序 更容易实现 SC &#x2F; TSO 等要求 tot...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">xixi</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">49</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">30</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xixi-shredp"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xixi-shredp" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my blog, for learning and communication purposes only. If there is any copyright infringement, please leave a message via email on GitHub.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%A2%84%E5%8F%96-Instruction-Prefetching"><span class="toc-number">1.</span> <span class="toc-text">指令预取 Instruction Prefetching</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Next-Line-Prefetching"><span class="toc-number">1.1.</span> <span class="toc-text">Next-Line Prefetching</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fetch-Directed-Prefetching"><span class="toc-number">1.2.</span> <span class="toc-text">Fetch-Directed Prefetching</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Fetch-Directed-Instruction-Prefetching-FDIP"><span class="toc-number">1.2.1.</span> <span class="toc-text">Fetch-Directed Instruction Prefetching (FDIP)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Discontinuity-Prefetching"><span class="toc-number">1.3.</span> <span class="toc-text">Discontinuity Prefetching</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Discontinuity-Predictor"><span class="toc-number">1.3.1.</span> <span class="toc-text">Discontinuity Predictor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prescient-Fetch"><span class="toc-number">1.4.</span> <span class="toc-text">Prescient Fetch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Temporal-Instruction-Fetch-Streaming-TIFS"><span class="toc-number">1.5.</span> <span class="toc-text">Temporal Instruction Fetch Streaming (TIFS)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Return-address-stack-Directed-Instruction-Prefetching-RDIP"><span class="toc-number">1.6.</span> <span class="toc-text">Return-address stack-Directed Instruction Prefetching (RDIP)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Proactive-Instruction-Fetch"><span class="toc-number">1.7.</span> <span class="toc-text">Proactive Instruction Fetch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">2.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/12/Arch/simulator/gem5/iew/" title="Gem5: Dispatch">Gem5: Dispatch</a><time datetime="2026-02-12T09:49:07.000Z" title="Created 2026-02-12 17:49:07">2026-02-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2026/02/11/Arch/simulator/gem5/prefetch/" title="Gem5 Prefetcher">Gem5 Prefetcher</a><time datetime="2026-02-11T15:56:47.000Z" title="Created 2026-02-11 23:56:47">2026-02-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/06/os/generic/mm/" title="OS Virtual Memory Management">OS Virtual Memory Management</a><time datetime="2025-11-06T06:03:30.000Z" title="Created 2025-11-06 14:03:30">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/06/os/linux/riscv/boot/" title="Linux RISC-V Boot 流程">Linux RISC-V Boot 流程</a><time datetime="2025-11-06T01:44:36.000Z" title="Created 2025-11-06 09:44:36">2025-11-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/11/04/os/linux/boot/" title="Linux Boot 过程">Linux Boot 过程</a><time datetime="2025-11-04T06:09:06.000Z" title="Created 2025-11-04 14:09:06">2025-11-04</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient(160deg, #4D063C, #3E064D, #23064D, #08064D);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 - 2026 By xixi</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></span></div><div class="footer_custom_text">Life is so Beautify!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.4"></script><script src="/js/main.js?v=5.5.4"></script><div class="js-pjax"><script>(() => {
  const parseViewBox = viewBox => {
    if (!viewBox) return null
    const parts = viewBox.trim().split(/[\s,]+/).map(n => Number(n))
    if (parts.length !== 4 || parts.some(n => Number.isNaN(n))) return null
    return parts
  }

  const getSvgViewBox = svg => {
    const attr = parseViewBox(svg.getAttribute('viewBox'))
    if (attr) return attr

    // Fallback: use bbox to build a viewBox
    try {
      const bbox = svg.getBBox()
      if (bbox && bbox.width && bbox.height) return [bbox.x, bbox.y, bbox.width, bbox.height]
    } catch (e) {
      // getBBox may fail on some edge cases; ignore
    }

    const w = Number(svg.getAttribute('width')) || 0
    const h = Number(svg.getAttribute('height')) || 0
    if (w > 0 && h > 0) return [0, 0, w, h]
    return [0, 0, 100, 100]
  }

  const setSvgViewBox = (svg, vb) => {
    svg.setAttribute('viewBox', `${vb[0]} ${vb[1]} ${vb[2]} ${vb[3]}`)
  }

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v))

  const openSvgInNewTab = ({ source, initViewBox }) => {
    const getClonedSvg = () => {
      if (typeof source === 'string') {
        const template = document.createElement('template')
        template.innerHTML = source.trim()
        const svg = template.content.querySelector('svg')
        return svg ? svg.cloneNode(true) : null
      }
      if (source && typeof source.cloneNode === 'function') {
        return source.cloneNode(true)
      }
      return null
    }

    const clone = getClonedSvg()
    if (!clone) return
    if (initViewBox && initViewBox.length === 4) {
      clone.setAttribute('viewBox', initViewBox.join(' '))
    }
    if (!clone.getAttribute('xmlns')) clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
    if (!clone.getAttribute('xmlns:xlink') && clone.outerHTML.includes('xlink:')) {
      clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink')
    }
    // inject background to match current theme
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark'
    const bg = getComputedStyle(document.body).backgroundColor || (isDark ? '#1e1e1e' : '#ffffff')
    if (!clone.style.background) clone.style.background = bg

    const serializer = new XMLSerializer()
    const svgSource = serializer.serializeToString(clone)
    const htmlSource = `<!doctype html><html><head><meta charset="utf-8" />
      <style>
        html, body { width: 100%; height: 100%; margin: 0; display: flex; align-items: center; justify-content: center; background: ${bg}; }
        svg { max-width: 100%; max-height: 100%; height: auto; width: auto; }
      </style>
      </head><body>${svgSource}</body></html>`
    const blob = new Blob([htmlSource], { type: 'text/html;charset=utf-8' })
    const url = URL.createObjectURL(blob)
    window.open(url, '_blank', 'noopener')
    setTimeout(() => URL.revokeObjectURL(url), 30000)
  }

  const attachMermaidViewerButton = wrap => {
    let btn = wrap.querySelector('.mermaid-open-btn')
    if (!btn) {
      btn = document.createElement('button')
      btn.type = 'button'
      btn.className = 'mermaid-open-btn'
      wrap.appendChild(btn)
    }

    btn.innerHTML = '<i class="fa fa-search fa-fw" aria-hidden="true"></i>'

    if (!btn.__mermaidViewerBound) {
      btn.addEventListener('click', e => {
        e.preventDefault()
        e.stopPropagation()
        const svg = wrap.__mermaidOriginalSvg || wrap.querySelector('svg')
        if (!svg) return
        const initViewBox = wrap.__mermaidInitViewBox
        if (typeof svg === 'string') {
          openSvgInNewTab({ source: svg, initViewBox })
          return
        }
        openSvgInNewTab({ source: svg, initViewBox })
      })
      btn.__mermaidViewerBound = true
    }
  }

  // Zoom around a point (px, py) in the SVG viewport (in viewBox coordinates)
  const zoomAtPoint = (vb, factor, px, py) => {
    const w = vb[2] * factor
    const h = vb[3] * factor
    const nx = px - (px - vb[0]) * factor
    const ny = py - (py - vb[1]) * factor
    return [nx, ny, w, h]
  }

  const initMermaidGestures = wrap => {
    const svg = wrap.querySelector('svg')
    if (!svg) return

    // Ensure viewBox exists so gestures always work
    const initVb = getSvgViewBox(svg)
    wrap.__mermaidInitViewBox = initVb
    wrap.__mermaidCurViewBox = initVb.slice()
    setSvgViewBox(svg, initVb)

    // Avoid binding multiple times on themeChange/pjax
    if (wrap.__mermaidGestureBound) return
    wrap.__mermaidGestureBound = true

    // Helper: map client (viewport) coordinate -> viewBox coordinate
    const clientToViewBox = (clientX, clientY) => {
      const rect = svg.getBoundingClientRect()
      const vb = wrap.__mermaidCurViewBox || getSvgViewBox(svg)
      const x = vb[0] + (clientX - rect.left) * (vb[2] / rect.width)
      const y = vb[1] + (clientY - rect.top) * (vb[3] / rect.height)
      return { x, y, rect, vb }
    }

    const state = {
      pointers: new Map(),
      startVb: null,
      startDist: 0,
      startCenter: null
    }

    const clampVb = vb => {
      const init = wrap.__mermaidInitViewBox || vb
      const minW = init[2] * 0.1
      const maxW = init[2] * 10
      const minH = init[3] * 0.1
      const maxH = init[3] * 10
      vb[2] = clamp(vb[2], minW, maxW)
      vb[3] = clamp(vb[3], minH, maxH)
      return vb
    }

    const setCurVb = vb => {
      vb = clampVb(vb)
      wrap.__mermaidCurViewBox = vb
      setSvgViewBox(svg, vb)
    }

    const onPointerDown = e => {
      // Allow only primary button for mouse
      if (e.pointerType === 'mouse' && e.button !== 0) return
      svg.setPointerCapture(e.pointerId)
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      if (state.pointers.size === 1) {
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      } else if (state.pointers.size === 2) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        state.startDist = Math.hypot(dx, dy)
        state.startVb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        state.startCenter = { x: (pts[0].x + pts[1].x) / 2, y: (pts[0].y + pts[1].y) / 2 }
      }
    }

    const onPointerMove = e => {
      if (!state.pointers.has(e.pointerId)) return
      state.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY })

      // Pan with 1 pointer
      if (state.pointers.size === 1 && state.startVb) {
        const p = [...state.pointers.values()][0]
        const prev = { x: e.clientX - e.movementX, y: e.clientY - e.movementY }
        // movementX/Y unreliable on touch, compute from stored last position
        const last = wrap.__mermaidLastSinglePointer || p
        const dxClient = p.x - last.x
        const dyClient = p.y - last.y
        wrap.__mermaidLastSinglePointer = p

        const { rect } = clientToViewBox(p.x, p.y)
        const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
        const dx = dxClient * (vb[2] / rect.width)
        const dy = dyClient * (vb[3] / rect.height)
        setCurVb([vb[0] - dx, vb[1] - dy, vb[2], vb[3]])
        return
      }

      // Pinch zoom with 2 pointers
      if (state.pointers.size === 2 && state.startVb && state.startDist > 0) {
        const pts = [...state.pointers.values()]
        const dx = pts[0].x - pts[1].x
        const dy = pts[0].y - pts[1].y
        const dist = Math.hypot(dx, dy)
        if (!dist) return
        const factor = state.startDist / dist // dist bigger => zoom in (viewBox smaller)

        const cx = (pts[0].x + pts[1].x) / 2
        const cy = (pts[0].y + pts[1].y) / 2
        const centerClient = { x: cx, y: cy }

        const pxy = clientToViewBox(centerClient.x, centerClient.y)
        const cpx = pxy.x
        const cpy = pxy.y

        const vb = zoomAtPoint(state.startVb, factor, cpx, cpy)
        setCurVb(vb)
      }
    }

    const onPointerUpOrCancel = e => {
      state.pointers.delete(e.pointerId)
      if (state.pointers.size === 0) {
        state.startVb = null
        state.startDist = 0
        state.startCenter = null
        wrap.__mermaidLastSinglePointer = null
      } else if (state.pointers.size === 1) {
        // reset single pointer baseline to avoid jump
        wrap.__mermaidLastSinglePointer = [...state.pointers.values()][0]
      }
    }

    // Wheel zoom (mouse/trackpad)
    const onWheel = e => {
      // ctrlKey on mac trackpad pinch; we treat both as zoom
      e.preventDefault()
      const delta = e.deltaY
      const zoomFactor = delta > 0 ? 1.1 : 0.9
      const { x, y } = clientToViewBox(e.clientX, e.clientY)
      const vb = (wrap.__mermaidCurViewBox || getSvgViewBox(svg)).slice()
      setCurVb(zoomAtPoint(vb, zoomFactor, x, y))
    }

    const onDblClick = () => {
      const init = wrap.__mermaidInitViewBox
      if (!init) return
      wrap.__mermaidCurViewBox = init.slice()
      setSvgViewBox(svg, init)
    }

    svg.addEventListener('pointerdown', onPointerDown)
    svg.addEventListener('pointermove', onPointerMove)
    svg.addEventListener('pointerup', onPointerUpOrCancel)
    svg.addEventListener('pointercancel', onPointerUpOrCancel)
    svg.addEventListener('wheel', onWheel, { passive: false })
    svg.addEventListener('dblclick', onDblClick)
  }

  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild

      // Clear old render (themeChange/pjax will rerun)
      const oldSvg = item.querySelector('svg')
      if (oldSvg) oldSvg.remove()
      item.__mermaidGestureBound = false

      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
        if (true) initMermaidGestures(item)
        item.__mermaidOriginalSvg = svg
        if (true) attachMermaidViewerButton(item)
      }


      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.2/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>